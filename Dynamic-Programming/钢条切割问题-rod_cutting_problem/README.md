## 一、动态规划(dynamic programming)简介
### 1、动态规划与分治法的关系（相似点与区别）
动态规划(dynamic programming)与分治法类似，都是通过组合子问题的解来求解原问题。不同点在于，**分治法**是将问题分为**互不相交的子问题**，递归地求解子问题，再将他们的解组合起来，求出原问题的解。与之相反，**动态规划**应用于**子问题重叠**的情况，即不同的子问题具有公共的子子问题(子问题的求解是递归进行的，将其划为更小的子子问题)。在这种情况下，分治算法会做许多不必要的工作，例如反复地求解那些公共子子问题。而动态规划算法对每个子子问题只求解一次，将其保存在一个表格中（dynamic programming中的programming不是代表着编写计算机程序，是代表着一种表格法），避免了不必要的计算工作。

概括如下：
- **相似点**： 将问题分解为子问题；将子问题的解组合为原问题的解
- **区别**： 子问题重叠 vs 子问题不重叠； 动态规划应用于优化问题。
###  2、动态规划一般的适用情况 
动态规划方法通常用来求解**最优化问题**(optimization problem)。这类问题通常有许多可行解，每个解都有一个值，我们希望寻找具有最优值的解（最大值或者最小值）。我们称这样的解为**一个最优解(an optimal solution)**,而不是**最优解(the optimal solution)**,因为可能有多个解都达到最优值。
### 3、动态规划的步骤
我们通常按照如下4个步骤来设计一个动态规划算法

-	刻画一个最优解的结构特征
-	递归地定义最优解的值
-	计算最优解的值，通常采用自底向上(boottom-up)的方法
-	利用计算出的信息构造一个最优解

上述4个步骤中，前三步即可求出一个最优解的值，如果我们仅仅需要这个值，而非解本身（解本身是指如何能实现这个最优值），可以忽略步骤4。如果需要做步骤4，有时需要在执行步骤3的过程中维护一些额外信息。

## 二、动态规划的典型应用场景
以下这些问题的描述、解决思路、伪代码实现主要来源于《算法导论》和[Thu-Bin Wang](http://cgcad.thss.tsinghua.edu.cn/wangbin/)老师的算法课课件，为了帮助理解这些问题，我把[Thu-Bin Wang](http://cgcad.thss.tsinghua.edu.cn/wangbin/)老师布置的一些作业题与自己的解答也贴在了每个问题后面，有兴趣的可以看看。
同时，注意一些新引入的概念，如：**最优子结构**...
### 1、钢条切割问题
#### a.问题描述
某公司出售长度为$i$英寸的钢条价格为$p_i$(i=1，2，3...)，价格表形式如下（单位：美元）：
| 长度$i$| 1 |2 |3| 4|5|6|7|8|9|10|
|--|--|--|--|--|--|--|---|---|-----|--|
|  价格$p_i$| 1 |5|8|9|10|17|17|20|24|30

现有一根长度$n$英寸的钢条,和一个价格表$p_i(i = 1, 2,3 ...n)$，求解切割方案，使得收益$r_n$最大。
#### b.问题分析
将钢条切割成若干段以求收益最大化，首先可能不切割。如在上表中,$n=2$时，要么将其切割为两段长度为1的钢条，此时收益为2美元；要么不切割直接出售，此时收益为5美元。此时不切割钢条实现了收益最大化。

所以假设一个最优解是将长度为n的钢条切割为$k$段，此时看$k$的取值范围应该是1$\leq$ $k$ $\leq$n，则分解发方案为下：$$n = i_1+i_2+....+i_k$$每一段的长度分别为$i_1,i_2,...i_k$，此时获得的收益为：$$r_n = p_{i_1}+p_{i_2}+...+p_{i_k}$$更一般地，对于$r_n(n\geq1)$，可以用更短钢条的最优切割收益来描述它：$$r_n =  max(p_n,r_1 +  r_{n-1}, r_2 + r_{n-2},...,r_{n-1} + r_1)  \qquad(1)$$上式很容易理解，第一个参数$p_n$对应不切割，其他的$n-1$个参数对应着另外$n-1$种方案：对于每个$i=1,2,...n-1$，首先将钢条切割为$i$和$n-i$两段，计算这两段的最优切割收益$r_i$和$r_{n-i}$，考虑所有可能的$i$，选取其中收益最大者。上述n种方案的最大收益，即为我们所求的最优切割收益。

注意到，为了求解规模为n的原问题，我们先求解形式完全一样，但是规模更小的子问题。现在引入一个新的定义**最优子结构(optimal substructure)**:问题的最优解由相关子问题的最优解组合而成，而这些子问题可以独立求解。对于钢条切割问题，我们通过组合两个相关子问题的最优解，并在所有可能的两段切割方案中选取组合收益最大者，构成原问题的最优解。此时钢条切割问题满足**最优子结构**性质。

除了上述解法，钢条切割问题还存在一种相似的但是更为简单的递归求解法：将钢条从左边切割下来长度为$i$的一段，只对右边剩下的长度为$n-i$的一段继续进行切割(递归求解)，对左边的一段则不再进行切割。即问题分解的方式为：将长度为n的钢条从左边开始一段，以及剩余部分继续分解的结果，这样，对于$(1)$式就有一个简化版本：$$r_n = max_{1\leq i\leq n}(p_i +  r_{n-i}) \qquad(2)$$在此公式中，原问题的最优解只包含一个相关子问题(右端剩余部分)的解，而不是两个。
#### c.代码实现
对于(2)式所展现的算法，首先我介绍一下伪代码的实现（我认为，对于一个特定算法，伪代码的实现与表示非常重要，可以指导我们将其实现为其他的具体的语言）。伪代码实现如下
```cpp
CUT-ROD(p, n)
	if n == 0
 		return 0
	q = −∞
	for i = 1 to n
		q = max(q, p[i] + CUT-ROD(p, n − i))
	return q
```
C++的(2)实现如下，也可以观察我在github上的实现代码[rod_cutting.cpp](https://github.com/LMLzz/DataStructure-Algorithm/blob/master/Dynamic-Programming/%E9%92%A2%E6%9D%A1%E5%88%87%E5%89%B2%E9%97%AE%E9%A2%98-rod_cutting_problem/rod_cutting.cpp)
```cpp
int cut_rod(const int *p, int n){
    if (n==0) 
        return 0;
    int q = INT_MIN; //此处需要#include<limits.h>
    for (int i=1; i<=n; ++i) {
        q = max(q, p[i] + cut_rod(p, n-i)); //此处需要#include<algorithm>
    }
    return q;
}
```
#### 时间复杂度分析
#### 改进后的算法 - 带备忘的自顶向下方法(top-down with memoization)
